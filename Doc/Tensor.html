<!DOCTYPE html><html>	<head>		<title> Tensor Documentation </title>	</head>	<body>		<h2> <code>template&lt;typename Scalar&gt; class Tensor; </code> </h2>		<h2> Description </h2>		<p>			Tensor est une simple implémentation d'un tableau de nombres de rang N utilisé par toutes les classes de la librairie afin de			faire transiter les données utilisées par les réseaux de neurones. Il s'agit de la structure de données principale de la bibliothèque.		</p>		<h2>			Paramètres templates		</h2>		<h3>			Scalar		</h3>		<p>			Scalar est le type des nombres stockés par la classe.		</p>		<h2>Constructeurs et Destructeurs</h2>		<hr>
		<font size="4"> <code>inline Tensor();</code> 		</font>		<p> Constructeur par défaut.</p><hr>
		<font size="4"> <code>inline explicit Tensor(const std::vector&lt;std::size_t&gt;& dims);</code> 		</font>		<p> <code>dims</code> contient les dimensions du tenseur. La mémoire pour les éléments du Tensor est allouée mais les éléments ne sont pas initialisés.</p><hr>
		<font size="4"> <code>inline explicit Tensor(const std::vector&lt;std::size_t&gt;& dims, const Scalar val);</code>        </font>        <p> <code>dims</code> contient les dimensions du tenseur. La mémoire pour les éléments du Tensor est allouée et ceux-ci sont initialisés à         	<code>val</code>. </p><hr>
        <font size="4"> <code>template&lt;typename ...Scalar_pack, typename = all_scalar_types&lt;std::size_t, Scalar_pack...&gt;&gt;<br>    		 inline explicit Tensor(const Scalar_pack ...dims); </code>     	</font>    	<p> Ce constructeur prend autant de paramètres que l'on veut, mais à la condition que ceux-ci soient convertible en <code>std::size_t</code> (sans quoi une erreur de compilation sera générée).    		Les paramètres représentent les dimensions du Tensor. La mémoire est allouée mais les éléments ne sont pas initialisés.</p><hr>
    	<font size="4"> <code>inline explicit Tensor(Scalar* data, const std::vector&lt;std::size_t&gt;& dims);</code>     	</font>    	<p> Ce constructeur prend un pointeur vers le début du tableau contenant les éléments du Tensor. dims représente les dimensions du Tensor.    		Avec ce constructeur, l'objet Tensor créé ne sera PAS propriétaire et responsable de la mémoire, sauf en cas d'appel à <code>resize()</code>.    	Ce constructeur est rarement censé être utilisé : il y a déjà des constructeurs par copie ou à partir de matrice. Il est présent pour des questions d'implémentation de certaines méthodes.</p><hr>
    	<font size="4"> <code>template&lt;typename ...Scalar_pack, typename = all_scalar_types&lt;std::size_t, Scalar_pack...&gt;&gt;<br>    		  inline explicit Tensor(const RMMat&lt;Scalar&gt;& mat, const Scalar_pack ...dims);</code>    	</font>    	<p> Ce constructeur prend une matrice <code>Eigen::Matrix</code> dynamique et RowMajor et copiera ses éléments. La taille du tenseur doit aussi être passée dans les arguments suivant. Ceux-ci doivent être convertibles en <code>std::size_t</code>, faute de quoi une erreur de compilation sera générée.</p><hr>
    	<font size="4"> <code>template&lt;typename ...Scalar_pack, typename = all_scalar_types&lt;std::size_t, Scalar_pack...&gt;&gt;<br>    		  inline explicit Tensor(const Mat&lt;Scalar, Eigen::ColMajor>& mat, const Scalar_pack ...dims);</code>    	</font>    	<p> NOTE : PAS ENCORE IMPLEMENTE!<br> Ce constructeur prend une matrice <code>Eigen::Matrix</code> dynamique et ColMajor et copiera ses éléments. La taille du tenseur doit aussi être passée dans les arguments suivant. Ceux-ci doivent être convertibles en <code>std::size_t</code>, faute de quoi une erreur de compilation sera générée.<hr>
    	<font size="4"> <code>inline explicit Tensor(const RMMat&lt;Scalar&gt;& mat);</code>    	</font>     	<p> Ce constructeur prend une matrice <code>Eigen::Matrix</code> dynamique et RowMajor et copiera ses éléments ainsi que ses dimensions. Le Tensor créé sera donc de rang 2.</p><hr>
        <font size="4"> <code>inline Tensor(const Tensor& tensor);</code>        </font>        <p> Constructeur par copie. Une copie "profonde" est effectuée : les éléments du Tensor sont copiés uns à uns.</p><hr>
        <font size="4"> <code>inline ~Tensor();</code> </font>        	<p> Destructeur, libère les ressources si l'objet en est propriétaire.</p>    	    	<h2>Opérateurs</h2><hr>
    	<font size="4"> <code>inline Tensor<Scalar>& operator=(const Tensor& rhs); </code> </font>     		<p> Operateur d'assignement. Effectue une copie profonde des éléments du Tensor.</p><hr>
    	<font size="4"> <code>inline Tensor<Scalar>& operator=(const std::initializer_list<Scalar>& list); </code> </font>     		<p> Operateur d'assignement : assigne les éléments de <code>list</code> au Tensor.</p><hr>
    	<font size="4"> <code>inline Tensor<Scalar>& operator+=(const Tensor& rhs); </code> </font>     		<p> Incrémentation de chaque élément par l'élément correspondant du Tensor <code>rhs</code>. Les deux Tensors doivent avoir des dimensions identiques. Sinon une assertion sera déclenchée. Au cas où celles-ci sont désactivées, le comportement est indéfini. </p><hr>
    	<font size="4"> <code>inline Tensor<Scalar>& operator-=(const Tensor& rhs); </code> </font>     		<p> Decrémentation de chaque élément par l'élément correspondant du Tensor <code>rhs</code>. Les deux Tensors doivent avoir des dimensions identiques. Sinon une assertion sera déclenchée. Au cas où celles-ci sont désactivées, le comportement est indéfini. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar>& operator+=(const Scalar rhs);<br> </code></font>        <p> Additionne le nombre <code>rhs</code> à chaque coefficient. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar>& operator-=(const Scalar rhs);<br> </code></font>        <p> Soustrait le nombre <code>rhs</code> à chaque coefficient. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar> operator+(const Tensor&lt;Scalar>& rhs) const;<br> </code></font>        <p> Retourne la somme coefficient à coefficient du <code>Tensor</code> et de <code>rhs.        </code> </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar> operator+(const Scalar rhs) const;<br> </code></font>        <p> Retourne le <code>Tensor,</code> dont on a additionné <code>rhs</code> à chaque coefficient. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar> operator-(const Scalar rhs) const;<br> </code></font>        <p> Retourne le <code>Tensor,</code> dont on a soustrait <code>rhs</code> à chaque coefficient. </p><hr>
    	<font size="4"> <code>inline Tensor<Scalar>& operator*=(const Tensor& rhs); </code> </font>     		<p> Multiplication de chaque élément par l'élément correspondant du Tensor <code>rhs</code>. Les deux Tensors doivent avoir des dimensions identiques. Sinon une assertion sera déclenchée. Au cas où celles-ci sont désactivées, le comportement est indéfini. </p><hr>
    	<font size="4"> <code>inline Tensor<Scalar>& operator*=(const Scalar rhs); </code> </font>     		<p> Multiplication par un scalaire. Chaque élément du Tensor est multiplié par le scalaire <code>rhs</code>. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar> operator*(const Tensor&lt;Scalar>& rhs) const;<br> </code></font>        <p> Retourne le produit coefficient à coefficient du <code>Tensor</code> avec le <code>Tensor</code> <code>rhs.        </code> </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar> operator*(const Scalar rhs) const;<br> </code></font>        <p> Retourne le <code>Tensor,</code> dont chaque coefficient a été multiplié par le scalare <code>rhs.        </code> </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar>& operator/=(const Scalar rhs);<br> </code></font>        <p> Divise chaque coefficient par le scalaire <code>rhs.        </code> </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar> operator/(const Tensor&lt;Scalar>& rhs) const;<br> </code></font>        <p> Retourne le quotient coefficient à coefficient du <code>Tensor</code> avec le <code>Tensor</code> <code>rhs.        </code> </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar> operator/(const Scalar rhs) const;<br> </code></font>        <p> Retourne le <code>Tensor,</code> dont chaque coefficient a été divisé par le scalare <code>rhs.        </code> </p><hr>
    	<font size="4"> <code>inline Scalar& operator[](const std::vector&lt;std::size_t&gt;& idx); </code> </font>     		<p> Retourne l'élément se trouvant à l'index <code>idx</code>. <code>idx</code> doit contenir autant de nombres que le rang du Tensor. </p><hr>
    	<font size="4"> <code>template&lt;typename ...IdxPack, typename = all_scalar_types&lt;std::size_t, IdxPack...&gt;&gt;<br>    	inline Tensor<Scalar> operator()(IdxPack ...idx); </code> </font>     		<p> S'il y a autant de paramètres que le rang du Tensor : retourne un Tensor à un élément avec l'élément indexé par les paramètres. Pour accéder à l'élément indexé, utiliser la méthode <code>item()</code>.     		Sinon, retourne le sous-Tensor se trouvant aux indices indiqués.</p>		<h2>Méthodes</h2><hr>
		<font size="4"> <code> inline Tensor&lt;Scalar>& plus_n_times(const Tensor&lt;Scalar>& rhs, const Scalar N); </code> </font>		<p> Incrémente chaque élément par l'élément correspondant du Tensor <code>rhs</code> multiplié par le scalaire <code>N</code>.			Le Tensor et <code>rhs</code> doivent avoir les même dimensions. Cette méthode est plus efficace que simplement<br>			<code>			tensor += rhs * N; <br> </code> (ou similaire).</p> <hr>
    	<font size="4"> <code> inline Tensor&lt;Scalar>& minus_n_times(const Tensor&lt;Scalar>& rhs, const Scalar N); </code> </font>    	<p> Decrémente chaque élément par l'élément correspondant du Tensor <code>rhs</code> multiplié par le scalaire <code>N</code>.			Le Tensor et <code>rhs</code> doivent avoir les même dimensions. Cette méthode est plus efficace que simplement<br>			<code>			tensor -= rhs * N; <br> </code> (ou similaire).</p> <hr>
        <font size="4"><code> template&lt;typename Callable><br>        inline Tensor&lt;Scalar>& foreach(const Callable& to_call);<br> </code></font>        <p>  Appelle le functor <code>to_call</code> pour chaque coefficient.         <code>to_call</code> doit prendre un <code>Scalar&</code> en paramètre et ne retourne rien         (ou sa valeur de retour sera ignorée). </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar>& square();<br> </code></font>        <p> Met chaque coefficient du <code>Tensor</code> au carré. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar>& sqrt();<br> </code></font>        <p> Remplace chaque coefficient par sa racine carrée. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar>& power(const Scalar x);<br> </code></font>        <p> Met chaque coefficient du <code>Tensor</code> à la puissance <code>x.        </code> </p><hr>
        <font size="4"><code> inline Scalar mean() const;<br> </code></font>        <p> Retourne la moyenne ou le centre des coefficients du <code>Tensor.        </code> </p><hr>
        <font size="4"><code> inline Scalar std() const;<br> </code></font>        <p> Retourne la variance des coefficients du <code>Tensor.        </code> </p><hr>
        <font size="4"><code> inline Scalar std(const Scalar _mean) const;<br> </code></font>        <p> Retourne l'écart-type des coefficients du <code>Tensor</code> autour de la moyenne passée dans l'argument <code>_mean.        </code> </p><hr>
        <font size="4"><code> inline Scalar var() const;<br> </code></font>        <p> Retourne la variance des coefficients du <code>Tensor.        </code> </p><hr>
        <font size="4"><code> inline Scalar var(const Scalar _mean) const;<br> </code></font>        <p> Retourne la variance des coefficients du <code>Tensor</code> autour de la moyenne passée dans l'argument <code>_mean.        </code> </p><hr>
        <font size="4"><code> inline Scalar sum();<br> </code></font>        <p> Retourne la somme des coefficients du <code>Tensor.        </code> </p><hr>
		<font size="4"> <code> template&lt;typename ...Scalar_pack, typename = all_scalar_types&lt;std::size_t, Scalar_pack...> > <br>    	inline Tensor&lt;Scalar>& resize(const Scalar_pack ...dims); </code> </font>     	<p> Redimensionne le Tensor en changeant le nombre total d'éléments. Les paramètres sont les nouvelles dimensions du Tensor. Ceux-ci doivent être convertibles en <code>std::size_t</code>, faute de quoi une erreur de compilation sera générée. </p><hr>
    	<font size="4"> <code> template&lt;typename ...Scalar_pack, typename = all_scalar_types&lt;std::size_t, Scalar_pack...> > <br>    	inline Tensor&lt;Scalar> reshape(const Scalar_pack ...dims) const; </code> </font>     	<p> Retourne une copie du Tensor redimensionnée. L'objet à partir duquel la méthode est appelée n'est pas modifié. Cette méthode doit être utilisée si le nombre d'éléments total ne change pas. Les paramètres sont les nouvelles dimensions du Tensor, et ceux-ci doivent être convertibles en <code>std::size_t</code>, faute de quoi une erreur de compilation sera générée. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar> reshape(const std::vector&lt;std::size_t>& dims) const;<br> </code></font>        <p>  Retourne une copie du Tensor redimensionnée. L'objet à partir duquel         la méthode est appelée n'est pas modifié. Cette méthode doit être         utilisée si le nombre d'éléments total ne change pas.         Cette méthode prend en paramètre un <code>vector</code> contenant les nouvelles dimensions. </p><hr>
    	<font size="4"> <code> template&lt;typename ...Scalar_pack, typename = all_scalar_types&lt;std::size_t, Scalar_pack...> > <br>     	inline Tensor&lt;Scalar>& reshape_in_place(const Scalar_pack ...dims); </code> </font>     	<p> Retourne une copie du Tensor redimensionnée. L'objet à partir duquel la méthode est appelée est lui aussi redimensionné. Cette méthode doit être utilisée si le nombre d'éléments total ne change pas. Sinon, voir <code>resize</code>. Les paramètres sont les nouvelles dimensions du Tensor, et ceux-ci doivent être convertibles en <code>std::size_t</code>, faute de quoi une erreur de compilation sera générée. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar>& reshape_in_place(const std::vector&lt;std::size_t>& dims);<br> </code></font>        <p>  Retourne une copie du Tensor redimensionnée. L'objet à partir         duquel la méthode est lui aussi redimensionné. Cette méthode doit         être utilisée si le nombre d'éléments total ne change pas. Sinon,         voir resize. Cette méthode prend en paramètre un <code>vector</code> contenant         les nouvelles dimensions. </p><hr>
         <font size="4"><code> template&lt;typename ...Scalar_pack,<br>        typename = all_scalar_types&lt;std::size_t, Scalar_pack...> ><br>        inline void reshape_in_place_no_return(const Scalar_pack ...dims);<br> </code></font>        <p> Méthode identique à <code>reshape_in_place,</code> mais ne retourne rien. </p><hr>
        <font size="4"><code> inline void reshape_in_place_no_return(const std::vector&lt;std::size_t>& dims);<br> </code></font>        <p> Méthode identique à <code>reshape_in_place,</code> mais ne retourne rien. </p><hr>
    	<font size="4"> <code>inline Eigen::Map&lt;RMMat&lt;Scalar> > as_matrix(const std::size_t rows, const std::size_t cols);    	</code> </font>     	<p> Retourne une matrice dynamique et RowMajor ayant une vue sur les éléments du Tensor. Les paramètres sont le nombre de lignes et de colonnes de la matrice. </p><hr>
    	<font size="4"> <code>inline Eigen::Map&lt;RMMat&lt;Scalar> > as_matrix();     	</code> </font>     	<p> Retourne une matrice dynamique et RowMajor ayant une vue sur les éléments du Tensor. Cette méthode ne fonctionne que si le Tensor est de rang 2, auquel cas le nombre de lignes et de colonnes de la matrice seront automatiquement déduits des dimensions du Tensor. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar>& set_value(const Scalar val, const std::size_t size);<br> </code></font>        <p> Assigne la valeur <code>val</code> aux <code>size</code> premiers éléments. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar>& set_value(const Scalar val);<br> </code></font>        <p> Assigne la valeur <code>val</code> à tous les éléments. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar>& set_zero();<br> </code></font>        <p> Assigne 0 à tous les éléments. </p><hr>
        <font size="4"><code> inline Tensor&lt;Scalar>& set_one();<br> </code></font>        <p> ASsigne 1 à tous les éléments. </p><hr>
        <font size="4"><code> inline std::size_t argmax() const;<br> </code></font>        <p> Retourne l'index linéarisé de l'élément le plus gran contenu. </p>    	<hr>
    	<font size="4"> <code> inline const std::vector<std::size_t>& get_dimensions() const { return m_dims; }    	</code> </font>     	<p> Retourne une référence constante sur le <code>std::vector</code> contenant les dimensions du Tensor. </p><hr>
    	<font size="4"> <code> inline Scalar* data() const { return m_data; }    	</code> </font>     	<p> Retourne un pointeur sur le premier élément du tableau style C contenant les éléments du Tensor. </p><hr>
    	<font size="4"> <code> inline Scalar& item() { return *m_data; }    	</code> </font>     	<p> Retourne le premier élément du Tensor (fait pour être utilisé avec un Tensor ne contenant qu'un seul élément). </p><hr>
    	<font size="4"> <code> inline std::size_t linearize_index(const std::vector<std::size_t>& idx);    	</code> </font>     	<p> Transforme un <code>std::vector</code> contenant des indices en l'index correspondant à ces indices dans le tableau style C conteant les éléments du Tensor. <br> Note : Ne devrait rarement avoir à être utilisé. </p>		<h2>Fonctions libres</h2><hr>
		<font size="4"> <code> template&lt;typename Scalar>		inline std::ostream& operator&lt;&lt;(std::ostream& out_str, const Tensor&lt;Scalar>& ten)			</code> </font> 		<p> Permet d'écrire le Tensor dans un flux. Exemple : <br> <code>Tensor&lt;double> tensor = random_tensor_d(3, 4);<br>std::cout << tensor;</code> </p><hr>
		<font size="4"> <code> template&lt;typename ...SizePack, typename = all_scalar_types&lt;std::size_t, SizePack...> > <br>		Tensor&lt;double> random_tensor_d(SizePack&& ...dims);		</code> </font> 		<p> Crée un Tensor contenant des nombres de type <code>double</code> générés aléatoirement selon une distribution uniforme entre 0 et 1.			Les paramètres sont les dimensions du Tensor, et ceux-ci doivent être convertibles en <code>std::size_t</code>, faute de quoi une erreur de compilation sera générée. </p><hr>
        <font size="4"><code> template&lt;typename ...SizePack, typename = all_scalar_types&lt;std::size_t, SizePack...> ><br>        Tensor&lt;double> randn_tensor_d(const double mean, const double stddev, SizePack&& ...dims;<br> </code></font>        <p>  Crée un Tensor contenant des nombres de type <code>double</code>         générés aléatoirement selon une distribution normale de moyenne <code>mean</code> et d'écart-type <code>stddev.        </code> Les deux premiers paramètres sont le centre et l'écart-type de la distribution, et les suivants         sont les dimensions du Tensor, qui doivent être convertibles         en <code>std::size_t</code>, faute de quoi une erreur de compilation sera générée. </p><hr>
		<font size="4"> <code> template &lt;typename ReturnScalar=int, typename ...SizePack, typename = all_scalar_types&lt;std::size_t, SizePack...> > <br>		Tensor&lt;ReturnScalar> random_tensor_i(const int min, const int max, SizePack&& ...dims);		</code> </font> 		<p> Crée un <code>Tensor&lt;ReturnScalar> </code>contenant des nombres entiers générés aléatoirement selon une distribution uniforme entre 			<code>min</code> et <code>max</code>. 			Les paramètres après les deux premiers sont les dimensions du Tensor, et ceux-ci doivent être convertibles en <code>std::size_t</code>, faute de quoi une erreur de compilation sera générée. </p><hr>
        <font size="4"><code> template &lt;typename ReturnScalar=int, typename ...SizePack, typename = all_scalar_types&lt;std::size_t, SizePack...> ><br>        Tensor&lt;ReturnScalar> zero_tensor(SizePack&& ...dims;<br> </code></font>        <p> Retourne un <code>Tensor</code> de dimensions <code>...dims</code> ne contenant que des zéros. Les dimensions doivent être convertibles en <code>std::size_t.        </code> </p><hr>
		<font size="4"> <code> template &lt;typename T1, typename T2> <br>		bool tensor_almost_equal(const Tensor&lt;T1>& t1, const Tensor&lt;T2>& t2, const double epsilon=1e-6)		</code> </font> 		<p> Vérifie que deux Tensor <code>t1</code> et <code>t2</code>, de même dimension, contiennent des valeurs identiques à <code>epsilon</code> près. 		</p>		<h2>Notes</h2>		<p> Lorsqu'un Tensor est créé avec la méthode operator(), la mémoire allouée au Tensor est libérée au moment où le Tensor qui a été indexé est détruit. C'est pourquoi il faut bien faire attention à ce que le Tensor "original" ne soit pas détruit lorsqu'un de ses "sous-tenseurs" est encore utilisé.		</p>	</body></html>