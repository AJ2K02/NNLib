<!DOCTYPE html><html><head>	<title>Transformations</title></head><body>	<h1>Les transformations</h1>	<p>Les transformations sont des classes contenant deux méthodes au maximum : <code>encode</code> et <code>decode</code>. Celles-ci permettent d'effectuer des transformations sur des objets de type <code>Tensor</code>. Par exemple, si vous souhaitez normaliser les valeurs des images d'une base de donnée, vous pouvez utiliser une transformation.</p>	<h2>La structure Transform</h2>	<p>Chaque structure repreésentant une transformation doit hériter de la structure <code>Transform</code>.</p> Celle-ci contient simplement deux méthodes virtuelles (faites pour être réimplémentées dans la classe fille) : <code>encode</code> et <code>decode</code>.<hr>
	<font size="4"><code> inline virtual void encode(Tensor&lt;Real>& x);<br> </code></font>	<p> Méthode servant à encoder les valeurs du <code>Tensor</code> <code>x.</code> En d'autres termes, cette méthode effectue la transformation. </p><hr>
	<font size="4"><code> inline virtual void decode(Tensor&lt;Real>& x);<br> </code></font>	<p>  Méthode servant à décoder les valeurs du Tensor x. En d'autres termes, cette méthode "annule" la transformation qui a été effectuée.	 Il n'est pas nécessaire d'implémenter cette méthode dans la plupart des cas. Par exemple, si vous souhaitez simplement effectuer	 des transformations sur les données avant l'apprentissage, cette méthode est inutile. </p>	 <h2>Liste des transformations implémentées</h2>	 <h3>Reshape</h3>	 <p>La transformation <code>Reshape</code> redimensionne le tenseur qui lui sera passé.	 Les nouvelles tailles lui sont passées par paramètre template. Exemple :<br></p>	 <code>Reshape<2, 3, 4>().encode(mon_tenseur);</code>	 <h3>Batch</h3>	 <p>La transformation <code>Batch</code> redimensionne le tenseur qui lui sera passé en séparant la première dimension en deux dimensions.	 Son constructeur prend un paramètre <code>_batch_size</code> indiquant la taille d'un batch. La première dimension D1 du tenseur sera alors séparée en deux dimensions de tailles <code>D1/_batch_size</code> et <code>_batch_size</code></p>	 <h3>Divide</h3>	 <p>La transformation <code>Divide</code> permet de diviser chaque valeur d'un <code>Tensor</code> par une constante passée en paramètre au constructeur de la transformation. Cette transformation peut être utile, par exemple, pour ramener chaque pixel d'une image dans l'intervalle [0;1] au lieu de [0;255].	 <h3>Standardize</h3>	 <p>La transformation <code>Standardize</code> calcul le centre <code>u</code> et l'écart-type <code>s</code> du tenseur passé en entrée. Ensuite, elle lui soustrait <code>u</code> et divise le résultat par <code>s</code>. Cette transformation a pour effet de "standardiser" le tenseur : c'est à dire qu'il aura un centre de 0 et un écart-type de 1.	 <h3>ToOneHot</h3>	 <p>La transformation <code>ToOneHot</code> est une transformation visant à être utilisée sur les étiquettes. Elle permet de transformer chaque valeur i en un vecteur (=un tenseur à une dimension) contenant uniquement des zéros, sauf un un à l'index i.	 Son constructeur prend un paramètre <code>_classes</code> indiquant le nombre de classes (et donc la longueur des vecteurs de zéros).<br>	 Par exemple, si on a un vecteur <code>labels</code> de taille 100x1 représentant les étiquettes de 500 images de la base de donnée CIFAR-10, on peut le transformer en un vecteur one-hot de la manière suivante : </p>	 <code>ToOneHot(10).encode(labels);</code>	 <p>Si les deux premiers éléments du tenseur étaient 2 et 6, ils seront remplacés par <br>{0, 0, 1, 0, 0, 0, 0, 0, 0, 0} et<br>{0, 0, 0, 0, 0, 0, 1, 0, 0, 0}</p>  		<h2>Ajout d'une nouvelle transformation</h2>		<p>Pour ajouter une nouvelle transformation, il suffit de créer une structure héritant de <code>Transform</code> et implémentant en tout cas la méthode <code>encode</code>. Notez que les tenseurs passés en paramètre aux fonctions <code>encode</code> et <code>decode</code> peuvent être très volumineux, d'où l'intérêt d'éviter les copies de ces derniers.</p>		Voici, par exemple, le code de la transformation <code>Divide</code>.<br>		<code>struct Divide : public Transform {<br>	    Divide(const Real _d) : m_d(_d) {};<br><br>	    inline void encode(Tensor<Real>& x) {<br>	        x /= m_d;<br>	    }<br><br>	    inline void decode(Tensor<Real>& x) {<br>	        x *= m_d;<br>	    }<br><br>	    Real m_d;<br>		};</code></body></html>